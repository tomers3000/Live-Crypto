<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Crypto: BTC & ETH (15min, improved)</title>
  <style>
    :root {
      --bg: #0b1020;
      --card: #151c34;
      --ink: #e9eefc;
      --muted: #93a0c6;
      --up: #18c77c;
      --down: #ff6b6b;
      --accent: #6aa4ff;
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background: linear-gradient(180deg, #0b1020, #0e1530);
      color: var(--ink);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .wrap { width: min(1100px, 100%); margin: auto; }
    header {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    h1 { font-size: 22px; font-weight: 700; margin: 0; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      background: var(--accent);
      color: #081025;
      border: none;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(106, 164, 255, .25);
    }
    .muted { color: var(--muted); font-size: 13px; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 24px;
    }
    .card {
      background: linear-gradient(180deg, var(--card), #11182e);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 16px;
      padding: 24px 18px 18px 18px;
      box-shadow: 0 12px 34px rgba(0,0,0,.35);
      min-height: 480px;
    }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .asset { display: flex; align-items: center; gap: 10px; }
    .icon {
      width: 42px; height: 42px; border-radius: 12px;
      display: grid; place-items: center; background: rgba(255,255,255,.06); font-size: 22px;
    }
    .sym { font-weight: 800; letter-spacing: .5px; }
    .name { color: var(--muted); font-size: 13px; }
    .price { font-feature-settings: "tnum" 1,"lnum" 1; font-variant-numeric: tabular-nums; font-size: 33px; font-weight: 800;}
    .sub { margin-top: 6px; color: var(--muted); font-size: 13px; display: flex; gap: 10px; align-items: center;}
    .err { color: #ff6b6b; font-weight: bold; }
    .error-msg { color: #ff6b6b; background: #181c2c; border-radius: 8px; padding: 8px 12px; margin: 10px 0 0 0; font-size: 15px;}
    footer { margin-top: 14px }
    a { color: #a9c7ff }
    .chart-container { margin-top: 22px; position: relative; height: 260px; }
    .gauge-container {
      width: 100%; display: flex; justify-content: center; margin-top: 18px; margin-bottom: 18px;
      position: relative; height: 90px; flex-direction: column; align-items: center;
    }
    .gauge-canvas-wrap {
      width: 140px; height: 70px;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: flex-end;
    }
    .gauge-percent {
      display: block;
      text-align: center;
      margin-top: 6px;
      font-size: 13px;
      color: #a9c7ff;
      letter-spacing: 0.5px;
    }
    .gauge-percent .value {
      font-size: 18px;
      color: #ffe680;
      font-weight: bold;
      margin-left: 3px;
    }
    .chart-spinner { display: none; }
    .levels { display: flex; justify-content: space-between; margin-top: 10px; font-size: 12px;}
    .levels .support { color: var(--up);}
    .levels .resistance { color: var(--down);}
    .volume-indicator { margin-top: 8px; font-size: 13px; text-align: center; border-radius: 8px; padding: 4px; background: rgba(255,255,255,0.1); }
    .volume-indicator.high { background: var(--accent); color: black; }
    .volume-indicator.low { background: #7a88a0; color: var(--ink);}
    .volume-stats { margin-top: 8px; font-size: 12px; text-align: center;}
    @media (max-width: 600px) {
      body { font-size: 18px; }
      .price { font-size: 22px; }
      h1 { font-size: 18px; }
      .gauge-percent { font-size: 10px; }
      .gauge-percent .value { font-size: 13px; }
      .card { padding: 12px; min-height: 340px;}
      .chart-container { height: 170px; }
      .gauge-container { height: 84px; margin-bottom: 8px; }
      .gauge-canvas-wrap { width: 100px; height: 50px;}
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@4.0.0/dist/chartjs-plugin-annotation.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Live Crypto — BTC & ETH <span class="muted">(15min, improved)</span></h1>
      <div class="controls">
        <button id="refreshBtn" title="Manual refresh" aria-label="Refresh data now">Refresh Now</button>
        <span id="lastUpdated" class="muted">Updating…</span>
      </div>
    </header>
    <section class="grid" id="cards">
      <div class="card" id="BTC">
        <div class="row">
          <div class="asset">
            <div class="icon">₿</div>
            <div>
              <div class="sym">BTC</div>
              <div class="name">Bitcoin</div>
            </div>
          </div>
          <div class="price" id="BTC_usd">—</div>
        </div>
        <div class="sub">
          <span id="BTC_ils">—</span>
          <span id="BTC_note" class="muted"></span>
        </div>
        <div class="error-msg" id="BTC_error_msg" style="display:none"></div>
        <div class="chart-container">
          <div class="chart-spinner" id="BTC_chart_spinner"></div>
          <canvas id="BTC_chart"></canvas>
        </div>
        <div class="gauge-container">
          <div class="gauge-canvas-wrap">
            <canvas id="BTC_gauge" width="140" height="70"></canvas>
          </div>
          <div class="gauge-percent" id="BTC_gauge_percent"></div>
        </div>
        <div class="levels">
          <span class="support">Nearest support: <span id="BTC_support_price">—</span></span>
          <span class="resistance">Nearest resistance: <span id="BTC_resistance_price">—</span></span>
        </div>
        <div class="volume-indicator" id="BTC_volume_indicator">
          <span>Volume (24h):</span> <span id="BTC_volume_24h"> —</span> <span id="BTC_volume_status"></span>
        </div>
        <div class="volume-stats muted">
          <span>20d daily avg:</span> <span id="BTC_volume_avg">—</span>
        </div>
      </div>
      <div class="card" id="ETH">
        <div class="row">
          <div class="asset">
            <div class="icon">Ξ</div>
            <div>
              <div class="sym">ETH</div>
              <div class="name">Ethereum</div>
            </div>
          </div>
          <div class="price" id="ETH_usd">—</div>
        </div>
        <div class="sub">
          <span id="ETH_ils">—</span>
          <span id="ETH_note" class="muted"></span>
        </div>
        <div class="error-msg" id="ETH_error_msg" style="display:none"></div>
        <div class="chart-container">
          <div class="chart-spinner" id="ETH_chart_spinner"></div>
          <canvas id="ETH_chart"></canvas>
        </div>
        <div class="gauge-container">
          <div class="gauge-canvas-wrap">
            <canvas id="ETH_gauge" width="140" height="70"></canvas>
          </div>
          <div class="gauge-percent" id="ETH_gauge_percent"></div>
        </div>
        <div class="levels">
          <span class="support">Nearest support: <span id="ETH_support_price">—</span></span>
          <span class="resistance">Nearest resistance: <span id="ETH_resistance_price">—</span></span>
        </div>
        <div class="volume-indicator" id="ETH_volume_indicator">
          <span>Volume (24h):</span> <span id="ETH_volume_24h"> —</span> <span id="ETH_volume_status"></span>
        </div>
        <div class="volume-stats muted">
          <span>20d daily avg:</span> <span id="ETH_volume_avg">—</span>
        </div>
      </div>
    </section>
    <footer class="muted">
      Source: Coinbase Spot, CryptoCompare (15min), Exchange Rates (Binance fallback if failure). Auto refresh every 15 seconds.
    </footer>
  </div>
  <script>
    // ==== UTILITIES ====
    const REFRESH_MS = 15000;
    function getHistoryUrl(asset) {
      return `https://min-api.cryptocompare.com/data/v2/histominute?fsym=${asset}&tsym=USD&limit=768&aggregate=15`;
    }
    const ENDPOINTS = {
      BTC_USD: 'https://api.coinbase.com/v2/prices/BTC-USD/spot',
      ETH_USD: 'https://api.coinbase.com/v2/prices/ETH-USD/spot',
      USD_RATES: 'https://api.coinbase.com/v2/exchange-rates?currency=USD',
      BINANCE_BTC: 'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',
      BINANCE_ETH: 'https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT',
    };
    const fmtILS = new Intl.NumberFormat('he-IL', { style: 'currency', currency: 'ILS' });
    const fmtTime = () => new Date().toLocaleString('en-US', { hour12: false });
    const fmtVolume = (num) => {
      if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
      return num.toFixed(0);
    };
    function fmtUSDshort(num) {
      if (num >= 1e9) return '$' + (num / 1e9).toFixed(1) + 'b';
      if (num >= 1e6) return '$' + (num / 1e6).toFixed(1) + 'm';
      if (num >= 1e3) return '$' + (num / 1e3).toFixed(1) + 'k';
      return '$' + num.toFixed(1);
    }
    function fmtUSD(num) {
      return '$' + num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    const chartInstances = {};

    // ==== DATA FETCH ====
    async function fetchJson(url) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) {
          let txt = '';
          try { txt = await res.text() } catch { }
          throw new Error(`HTTP ${res.status} from ${url}${txt ? ': '+txt : ''}`);
        }
        return await res.json();
      } catch (e) {
        throw new Error(`Network/API error: ${e.message}`);
      }
    }

    async function getUsdToIls() {
      try {
        const data = await fetchJson(ENDPOINTS.USD_RATES);
        const ils = Number(data?.data?.rates?.ILS);
        if (!isFinite(ils)) throw new Error('No ILS rate');
        return ils;
      } catch (e) {
        window.lastFetchError = e.message || e.toString();
        return null;
      }
    }
    async function getSpotUSD(asset) {
      try {
        const url = asset === 'BTC' ? ENDPOINTS.BTC_USD : ENDPOINTS.ETH_USD;
        const data = await fetchJson(url);
        const amt = Number(data?.data?.amount);
        if (!isFinite(amt)) throw new Error('Bad spot amount');
        return { price: amt, source: 'Coinbase' };
      } catch (e) {
        window.lastFetchError = e.message || e.toString();
        try {
          const url2 = asset === 'BTC' ? ENDPOINTS.BINANCE_BTC : ENDPOINTS.BINANCE_ETH;
          const data = await fetchJson(url2);
          const amt = Number(data?.price);
          if (!isFinite(amt)) throw new Error('Bad binance price');
          return { price: amt, source: 'Binance (USDT≈USD)' };
        } catch (e2) {
          window.lastFetchError = e2.message || e2.toString();
          throw e2;
        }
      }
    }
    async function fetchHistoricalData(asset) {
      try {
        const url = getHistoryUrl(asset);
        const data = await fetchJson(url);
        if (!data?.Data?.Data) {
          if(data?.Message) throw new Error("API: " + data.Message);
          throw new Error('No historical prices from API');
        }
        return data.Data.Data.map(item => ({
          time: item.time * 1000,
          price: item.close === 0 ? null : item.close,
          volume: item.volumeto
        }));
      } catch (e) {
        window.lastFetchError = e.message || e.toString();
        console.error("fetchHistoricalData error for", asset, e, window.lastFetchError);
        return [];
      }
    }
    function calculateLevels(historicalData) {
      const prices = historicalData.map(d => d.price).filter(x => x != null);
      if (!prices.length) return { support: null, resistance: null };
      const min = Math.min(...prices);
      const max = Math.max(...prices);
      return { support: min, resistance: max };
    }
    function calculateAverageVolume(historicalData) {
      const volumes = historicalData.filter(item => item.price != null).map(item => item.volume);
      if (!volumes.length) return 0;
      const totalVolume = volumes.reduce((sum, v) => sum + v, 0);
      return totalVolume / volumes.length;
    }

    // ==== CHART ====
    function renderChart(asset, prices, levels) {
      const canvasEl = document.getElementById(`${asset}_chart`);
      if (chartInstances[asset]) chartInstances[asset].destroy();
      if (prices.length === 0 || !canvasEl) return;
      const labels = prices.map(p => {
        const d = new Date(p.time);
        const h = d.getHours().toString().padStart(2, '0');
        const m = d.getMinutes().toString().padStart(2, '0');
        return h + ':' + m;
      });
      const data = prices.map(p => p.price);
      const isUp = (() => {
        const first = data.find(x => x != null);
        const last = [...data].reverse().find(x => x != null);
        return last >= first;
      })();
      const chartColor = getComputedStyle(document.documentElement).getPropertyValue(isUp ? '--up' : '--down');
      const annotations = [];
      if (levels.resistance != null) {
        annotations.push({
          type: 'line',
          scaleID: 'y',
          value: levels.resistance,
          borderColor: 'rgba(255,99,132,0.7)',
          borderWidth: 1,
          borderDash: [5,5],
          label: {
            content: 'Resistance', enabled: true, position: 'end',
            color: 'rgba(255,99,132,1)', font: {size: 10}
          }
        });
      }
      if (levels.support != null) {
        annotations.push({
          type: 'line',
          scaleID: 'y',
          value: levels.support,
          borderColor: 'rgba(54,162,235,0.7)',
          borderWidth: 1,
          borderDash: [5,5],
          label: {
            content: 'Support', enabled: true, position: 'end',
            color: 'rgba(54,162,235,1)', font: {size: 10}
          }
        });
      }
      chartInstances[asset] = new Chart(canvasEl, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            borderColor: chartColor,
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
            tension: 0,
            spanGaps: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time (15min)',
                color: '#a9c7ff',
                font: { size: 13 }
              },
              ticks: {
                color: '#e9eefc',
                maxRotation: 32,
                autoSkip: false,
                maxTicksLimit: 10,
                callback: function(val, idx) {
                  if (labels.length <= 10) return this.getLabelForValue(val);
                  const every = Math.ceil(labels.length/10);
                  return idx % every === 0 ? this.getLabelForValue(val) : '';
                }
              },
              grid: { color: 'rgba(100,150,230,0.06)' }
            },
            y: {
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Price ($)',
                color: '#a9c7ff',
                font: { size: 13 }
              },
              ticks: {
                color: '#e9eefc',
                callback: function(value) {
                  return fmtUSDshort(value);
                },
                maxTicksLimit: 5
              },
              grid: { color: 'rgba(100,150,230,0.08)' }
            }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return fmtUSD(context.raw);
                }
              }
            },
            annotation: { annotations: annotations }
          }
        }
      });
    }

    // ==== GAUGE (סקאלה בלבד - בלי מחוג) ====
    function renderVolumeGauge(asset, currentVolume, averageVolume) {
      const gaugeEl = document.getElementById(`${asset}_gauge`);
      const percentEl = document.getElementById(`${asset}_gauge_percent`);
      if (!gaugeEl || !percentEl) return;
      const ctx = gaugeEl.getContext('2d');
      ctx.clearRect(0, 0, gaugeEl.width, gaugeEl.height);

      // מרכז חצי-העיגול בבסיס הקנבס
      const cx = gaugeEl.width / 2;
      const cy = gaugeEl.height;

      // רקע אפור (חצי עיגול)
      ctx.beginPath();
      ctx.arc(cx, cy, 52, Math.PI, 0, false);
      ctx.lineWidth = 15;
      ctx.strokeStyle = '#222e4d';
      ctx.stroke();

      // חישוב ratio
      let ratio = (averageVolume && currentVolume) ? currentVolume / averageVolume : 0;
      ratio = Math.max(0, Math.min(ratio, 2)); // 0..2

      // קשת צבעונית עד אחוז הווליום
      const angle = Math.PI - ratio * (Math.PI/2);
      ctx.beginPath();
      ctx.arc(cx, cy, 52, Math.PI, angle, true);
      ctx.lineWidth = 15;
      ctx.strokeStyle = ratio >= 1 ? '#18c77c' : '#ff6b6b';
      ctx.stroke();

      percentEl.innerHTML = `<span>Volume % <span class="value">${(ratio*100).toFixed(0)}%</span></span>`;
    }

    // ==== HELPERS ====
    function renderError(asset, msg) {
      const errorMsgEl = document.getElementById(`${asset}_error_msg`);
      if (errorMsgEl) {
        errorMsgEl.textContent = msg || window.lastFetchError || 'Unknown error';
        errorMsgEl.style.display = 'block';
      }
      console.error(`Error for ${asset}:`, msg || window.lastFetchError || 'Unknown error');
    }
    function clearError(asset) {
      const errorMsgEl = document.getElementById(`${asset}_error_msg`);
      if (errorMsgEl) errorMsgEl.style.display = 'none';
    }
    function renderAsset(asset, usdPrice, usdToIls, sourceTag) {
      const usdEl = document.getElementById(`${asset}_usd`);
      const ilsEl = document.getElementById(`${asset}_ils`);
      const noteEl = document.getElementById(`${asset}_note`);
      if (usdEl) usdEl.textContent = fmtUSD(usdPrice);
      if (ilsEl) {
        if (usdToIls) {
          ilsEl.textContent = `≈ ₪${(usdPrice * usdToIls).toLocaleString('he-IL', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        } else {
          ilsEl.textContent = '— (no ILS rate)';
        }
      }
      if (noteEl) noteEl.textContent = sourceTag ? `Source: ${sourceTag}` : '';
    }
    function renderLevels(asset, levels) {
      const supportEl = document.getElementById(`${asset}_support_price`);
      const resistanceEl = document.getElementById(`${asset}_resistance_price`);
      if (supportEl) supportEl.textContent = levels.support != null ? fmtUSDshort(levels.support) : '—';
      if (resistanceEl) resistanceEl.textContent = levels.resistance != null ? fmtUSDshort(levels.resistance) : '—';
    }
    function renderVolumeIndicator(asset, currentVolume, averageVolume) {
      const indicatorEl = document.getElementById(`${asset}_volume_indicator`);
      const volumeEl = document.getElementById(`${asset}_volume_24h`);
      const statusEl = document.getElementById(`${asset}_volume_status`);
      const avgVolumeEl = document.getElementById(`${asset}_volume_avg`);
      if (!indicatorEl || !volumeEl || !statusEl || !avgVolumeEl) return;
      volumeEl.textContent = `$${fmtVolume(currentVolume)}`;
      avgVolumeEl.textContent = `$${fmtVolume(averageVolume)}`;
      indicatorEl.classList.remove('high', 'low');
      if (currentVolume > averageVolume) {
        indicatorEl.classList.add('high');
        statusEl.textContent = ` (Above average)`;
      } else {
        indicatorEl.classList.add('low');
        statusEl.textContent = ` (Below average)`;
      }
    }

    // ==== MAIN UPDATE ====
    async function updateAll() {
      const lastUpdatedEl = document.getElementById('lastUpdated');
      if (lastUpdatedEl) lastUpdatedEl.textContent = 'Updating…';
      window.lastFetchError = null;
      try {
        clearError('BTC');
        clearError('ETH');
        const [btc, eth, usdToIls, btcHistory, ethHistory] = await Promise.all([
          getSpotUSD('BTC'),
          getSpotUSD('ETH'),
          getUsdToIls(),
          fetchHistoricalData('BTC'),
          fetchHistoricalData('ETH'),
        ]);
        const btcLevels = calculateLevels(btcHistory);
        const ethLevels = calculateLevels(ethHistory);
        renderAsset('BTC', btc.price, usdToIls, btc.source);
        renderAsset('ETH', eth.price, usdToIls, eth.source);
        renderChart('BTC', btcHistory, btcLevels);
        renderChart('ETH', ethHistory, ethLevels);
        renderLevels('BTC', btcLevels);
        renderLevels('ETH', ethLevels);
        if (btcHistory.length > 0) {
          const btcAvgVolume = calculateAverageVolume(btcHistory);
          let lastIdx = btcHistory.length - 1;
          while (lastIdx >= 0 && btcHistory[lastIdx].price == null) lastIdx--;
          const lastVolume = lastIdx >= 0 ? btcHistory[lastIdx].volume : 0;
          renderVolumeIndicator('BTC', lastVolume, btcAvgVolume);
          renderVolumeGauge('BTC', lastVolume, btcAvgVolume);
        } else {
          renderError('BTC', window.lastFetchError || 'No historical data available.');
          renderVolumeGauge('BTC', 0, 0);
        }
        if (ethHistory.length > 0) {
          const ethAvgVolume = calculateAverageVolume(ethHistory);
          let lastIdx = ethHistory.length - 1;
          while (lastIdx >= 0 && ethHistory[lastIdx].price == null) lastIdx--;
          const lastVolume = lastIdx >= 0 ? ethHistory[lastIdx].volume : 0;
          renderVolumeIndicator('ETH', lastVolume, ethAvgVolume);
          renderVolumeGauge('ETH', lastVolume, ethAvgVolume);
        } else {
          renderError('ETH', window.lastFetchError || 'No historical data available.');
          renderVolumeGauge('ETH', 0, 0);
        }
        if (lastUpdatedEl) lastUpdatedEl.textContent = `Updated: ${fmtTime()}`;
      } catch (e) {
        renderError('BTC', window.lastFetchError || 'General error. Try refreshing.');
        renderError('ETH', window.lastFetchError || 'General error. Try refreshing.');
        renderVolumeGauge('BTC', 0, 0);
        renderVolumeGauge('ETH', 0, 0);
        if (lastUpdatedEl) lastUpdatedEl.textContent = `Error updating (${fmtTime()}): ${window.lastFetchError||e.message}`;
      }
    }
    updateAll();
    const interval = setInterval(updateAll, REFRESH_MS);
    let lastManualRefresh = 0;
    document.getElementById('refreshBtn').addEventListener('click', () => {
      const now = Date.now();
      if (now - lastManualRefresh > 2000) {
        updateAll();
        lastManualRefresh = now;
      }
    });
    window.addEventListener('beforeunload', () => clearInterval(interval));
  </script>
</body>
</html>